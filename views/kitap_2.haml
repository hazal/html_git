-# coding: UTF-8

%div.row
  %div.leaderboard
    %h1 Bölüm 2 
    %h4 
      Yazar : 
      %a(href="http://twitter.com/#!/huwcol" target="_blank") Huw Collingbourne
      \- 
      %a(href="http://www.sapphiresteel.com/" target="_blank") www.sapphiresteel.com
    %h4 Çeviren : Ümit Kayacık

%br

%div.row
  %div.span12
    %h3  Sınıf Hiyerarşileri, Simgeler (Attributes) ve Sınıf Değişkenleri
    %p 
      Diyelim 
      %b Thing 
      (Şey) ve 
      %b Treasure 
      (Hazine) adında iki sınıfımız var. Bu iki sınıf ortak özelliklere sahip (her ikisi de 
      name adında değişkene sahip) ama ayrı ayrı sınıflar.
    %p
      Şimdi bu iki küçük sınıf gözönüne alındığında aynı şeyi tekrarlamak önemsiz gibi 
      görünebilir. Bunun yanında gerçek karmaşık programlar yazmaya başladığınızda 
      sınıflarınızın içinde birçok değişken ve metod olacaktır ve aynı şeyi tekrar 
      tekrar yazmayı istemeyeceksiniz.
    %p 
      Bir diğer özel (“ata”) sınıf olması ve diğer sınıfların bu 
      %b ata 
      sınıftan özelliklerini 
      %b kalıtım 
      yoluyla alması mantıklı olacaktır. Bizim basit macera oyunumuzda örneğin, 
      %b Treasure 
      sınıfı 
      %b Thing 
      sınıfının özel bir şekli. Yani 
      %b Treasure 
      sınıfı 
      %b Thing 
      sınıfının özelliklerini kalıtımla alıyor.
    %br
    
    %div.alert.alert-info
      %b Sınıf Hiyerarşilerileri – Dedeler ve Torunlar (Ancestors and Descendants): 
      Bu kitapta sık sık ‘dede’ sınıflarından özelliklerini ‘kalıtım’ yoluyla alan ‘torun’ 
      sınıflardan bahsedeceğim. Bu terimler aile bağları gibi birbirine ‘bağlı’ sınıflar için 
      tavsiye edilir. Ruby’de her sınıfın bir babası vardır. Bazen babası, dedesi, 
      büyükdedesi olan seçkin bir aile ağacından türemiş olabilir.
    %br
    
    %p
      %b Thing 
      sınıfının kendisinde ‘şey’lerin başlıca davranışı kodlanır. 
      %b Treasure 
      sınıfıysa, otomatik olarak bu özellikleri 
      %b Thing sınıfından alacaktır, böylece hepsini tekrar tanımlamaya gerek 
      yoktur; ancak sonrasında 
      %b Treasure 
      sınıfına özel davranışlar tanımlanır.
    %p
      Genel kural olarak, bir sınıf hiyerarşisi üretirken, en çok genel olan 
      davranışlar, daha özel olan davranışlara göre daha üst sınıflara gönderilir. 
      Yani 
      %b Thing 
      sınıfının sadece 
      %b name 
      ve  
      %b description özellikleri olup torunu 
      %b Treasure 
      sınıfı 
      %b name, description 
      ve ek olarak bir 
      %b value 
      özelliğine sahiptir. 
      %b Thing 
      sınıfı ayrıca 
      %b name, description 
      ve 
      %b exits 
      özellikleri olan 
      %b Room 
      sınıfının da atası olabilir vs.
    %br
    
    %div.alert.alert-info
      %b Bir baba, birçok çocuk
      %br
      %img(src="/dede_torun.png" alt="/dede_torun.png")
      %p
        Bu şekil 
        %i name 
        ve 
        %i description 
        özellikleri olan bir 
        %b Thing 
        sınıfı gösteriyor (Ruby’de bu özellikler 
        %b @name 
        ve 
        %b @description 
        dahili değişkenleri olup erişmek için birkaç metod içerebilir). 
        %b Treasure 
        ve 
        %b Room 
        sınıfları ikisi de 
        %b Thing 
        sınıfının torunlarıdır ve otomatikman 
        %i name 
        ve 
        %i description özelliklerini 
        %b kalıtım 
        yoluyla alırlar. 
        %b Treasure 
        sınıfı 
        %i value 
        isimli yeni bir özellik ekler - böylece name, description ve value özelliklerine 
        sahip olur ; 
        %b Room 
        sınıfı da 
        %i exits 
        özelliği ekler - böylece 
        %i name, description ve exits 
        özellikleri olur.
    %br
    
    %h4.sag 1adventure.rb
    :coderay
      #!Ruby
      # 1adventure.rb
      
      class Thing
        def initialize( aName, aDescription )
          @name         = aName
          @description  = aDescription
        end
        
        def get_name
          return @name
        end
        
        def set_name( aName )
          @name = aName
        end
        
        def get_description
          return @description
        end
        
        def set_description( aDescription )
          @description = aDescription
        end
      end      
      
      
      class Treasure < Thing      # Thing sınıfından Treasure torunu
        def initialize( aName, aDescription, aValue )
          super( aName, aDescription )
          @value = aValue
        end
        
        def get_value
          return @value
        end
        
        def set_value( aValue )
          @value = aValue
        end
      end
      
      
      # Burası programın başladığı yer...
      t1 = Treasure.new("Sword", "an Elvish weapon forged of gold",800)
      t2 = Treasure.new("Dragon Horde", "a huge pile of jewels", 550)  
      puts "Bu treasure1: \#{t1.inspect}"
      puts "Bu da treasure2: \#{t2.inspect}"
      puts "t1 name=\#{t1.get_name}, description=\#{t1.get_description},     
        value=\#{t1.get_value}"
      t1.set_value( 100 )
      t1.set_description(" (now somewhat tarnished)")
      puts "t1 (ŞİMDİKİ) name=\#{t1.get_name},
        description=\#{t1.get_description},
        value=\#{t1.get_value}"
    %br
    
    %p
      Haydi bir Ruby sınıfının torun sınıfının nasıl üretildiğine bakalım. 
      %b 1adventure.rb 
      programını yazın. Program oldukça basit bir şekilde 
      %b @name 
      ve 
      %b @description 
      oluşum değişkenlerine sahip Thing sınıfının tanımlanmasıyla başlıyor. Bu 
      değişkenler değerlerini new metoduyla Thing objesi üretildiğinde 
      %b initialize 
      metodu içinde alıyorlar. Oluşum değişkenleri genellikle dışardan erişilemez 
      (zaten öyle olması da gerekir). Bu değişkenlerin değerini elde edebilmek için 
      bir 
      %b accessor 
      (erişici) metod tanımlamamız gerekir. 
      %b get_name 
      ile 
      %i name 
      değerini okuyoruz ve 
      %b set_name 
      ile 
      %i name 
      değerini değiştiriyoruz.
    %br
    
    %h3 ÜST SINIF ve ALT SINIF (SUPERCLASSES AND SUBCLASSES)
    %p Şimdi Tereasure sınıfının nasıl tanımlandığına bakalım:
    %br
    
    :coderay
      #!Ruby
      class Treasure < Thing
    %br
    
    %p
      Küçüktür işareti 
      %b < 
      Treasure sınıfının Thing sınıfının bir ‘altsınıfı’ ya da torunu olduğunu ve 
      Thing sınıfının değişkenleri ve metodlarını kalıtım yoluyla alacağını gösteriyor. 
      Metodlar 
      %b get_name, set_name, get_description 
      ve 
      %b set_description 
      dede sınıf olan Thing içinde tanımlı olduğundan torun sınıf Treasure içinde 
      tekrar tanımlamanıza gerek yok.
    %p
      Treasure sınıfı bir tane fazladan veri içeriyor, değeri (
      %b @value
      ) ve sadece bunun için get ve set erişim metodları yazdım. Treasure sınıfı 
      üretildiğinde 
      %b initialize 
      metodu otomatik olarak çağırılır. Bir Treasure nesnesi üç değişkene sahiptir(
      %b @name, @description 
      ve 
      %b @value
      ) bu yüzden 
      %b initialize 
      metodu üç argüman alır. İlk iki argüman direk olarak 
      %b super 
      metodu kullanılarak üst sınıfın (Thing) 
      %b initialize 
      metoduna gönderilir ve Thing sınıfının 
      %b initialize 
      metodu bu değişkenleri işler.
    %br
    :coderay
      #!Ruby
      super( aName, aDescription )
    %br
    
    %p
      %b super 
      kelimesi bir metod yapısı içinde kullanıldığında ‘üst sınıf’ içindeki aynı isimli 
      metodu çağırır. Eğer 
      %b super 
      kelimesi tek başına kullanıldıysa içinde bulunduğu metoda gönderilen tüm 
      argümanları dede metoda gönderilir. Eğer burdaki gibi bir kısım argüman 
      verilmişse (burada 
      %b aName 
      ve 
      %b aDescription
      ) sadece bu argümanlar üst sınıfa gönderilir.
    %br
    
    %h3 ARGÜMANLARI ÜST SINIFA GÖNDERMEK
    %p
      Üst sınıf çağrılırken parantezler önemlidir! Eğer argüman listesi boş ve 
      parantez kullanılmamışsa içinde bulunulan metoda gönderilen tüm 
      argümanlar üst sınıfa gönderilir. Ama eğer argüman listesi boş ve parantez 
      kullanılmışsa üst sınıfa hiçbir argüman gönderilmez:
    %br
    %h4.sag super_args.rb
    :coderay
      #!Ruby
      # Bu a, b, c’yi üstsınıfa gönderir
      def initialize( a, b, c, d, e, f )
        super( a, b, c )
      end
      
      # Bu a, b, c’yi üstsınıfa gönderir
      def initialize( a, b, c )
        super
      end
      
      # Bu üstsınıfa hiçbir şey göndermez
      def initialize( a, b, c)
        super()
      end
    %br
    
    %div.alert.alert-info
      %p
        %b super 
        kelimesi kullanımını daha ayrıntılı anlamak için bu bölümün sonundaki 
        %b derinlemesine inceleme 
        kısmını okuyun
    %br
    
    %h3 ATANIN METODLARI
    %p
      Bizim geleceğin macera oyununda sınıflar sağlıklı çalışmasına rağmen hala 
      bazı gereksiz kod var, şu get ve set erişim kodları. Haydi bunları nasıl daha 
      akıllı bir görünüm yapabiliriz bakalım:
    %p
      %b @description 
      değişkenine aşağıdaki gibi 
      %b get_description 
      ve 
      %b set_description 
      metodları ile ulaşmak yerine...
    %br
    
    :coderay
      #!Ruby
      puts( t1.get_description )
      t1.set_description( "bir açıklama" )
    %br
    %p …şurdaki gibi basit bir değişken ataması şeklinde yapmak çok daha hoş olurdu değil mi?:
    %br
    
    :coderay
      #!Ruby
      puts( t1.description )
      t1.description = "bir açıklama"
    %br
    
    %p
      Bunu yapabilmek için, Treasure sınıf tanımlamasını modifiye etmek 
      zorundayız. Bunu yapmanın bir yolu 
      %b @description 
      erişim metodlarını aşağıdaki hale getirmektir:
    %br
    
    :coderay
      #!Ruby
      def description
        return @description
      end
      
      def description=( aDescription )
        @description = aDescription
      end
    %br
    
    %p
      Yukardakine benzer şekilde Thing sınıfı tanımlamasını 
      %b accessors1.rb 
      dosyasına yeniden yapalım:
    %br
    
    %h4.sag accessors1.rb
    :coderay
      #!Ruby
      # The Book of Ruby - http://www.sapphiresteel.com
      # illustrates how to read and write instance variables
      # using accessor methods
      
      class Thing                            
        def initialize( aName, aDescription )            
          @name = aName
          @description = aDescription
        end
        
        # @name için get accessor
        def name
          return @name
        end
        
        # @name için set accessor
        def name=( aName )
          @name = aName
        end      
        
        # @description için get accessor
        def description
          return @description
        end
        
        # @description için set accessor
        def description=( aDescription )
          @description = aDescription
        end      
      end      
      
      t = Thing.new("The Thing", "a lovely, glittery wotsit")
      print( t.name )
      print( " is " )
      puts( t.description )
      t.name = "A Refurbished Thing"
      t.description = "a bit faded and worn around the edges"
      print( "It has now changed its name to " )
      puts( t.name )
      print( "I would describe it as " )
      puts( t.description )
    %br
    
    %p
      Burada get erişimcisi için 
      %b description 
      ve set erişimcisi için 
      %b description= 
      metodları kullanılmış. Ruby’de 
      %b = 
      işareti metod adına dahil edilebiliyor ve çok yararlı oluyor. Şimdi şöyle bir 
      string ataması yapmak mümkün:
    %br
    
    :coderay
      #!Ruby
      t.description = "a bit faded and worn around the edges”
    %br
    
    %p ve değeri de şöyle öğrenebilirsiniz:
    %br
    
    :coderay
      #!Ruby
      puts( t.description )
    %br
    
    %h3 Set Accessor’ları
    %p
      Bu yöntemle set erişimcisi yazdığınızda metod adına 
      %b = 
      işareti eklemeniz gerekir ama metod adından sonra boşluk vermeden.
    %p Yani bu doğru:
    %br
    
    :coderay
      #!Ruby
      def name=( aName )
    %br
    
    %p Ama bu yanlış:
    %br
    
    :coderay
      #!Ruby
      def name = ( aName )
    %br
    %hr
    
    %h3 ATTRIBUTE OKUYUCU ve YAZICILAR
    %p
      Gerçekte aynı sonucu elde edebileceğiniz daha kısa bir yol var. Tüm 
      yapmanız gereken iki özel metodu kullanmak, 
      %b attr_reader 
      ve 
      %b attr_writer 
      arkasından da sembol , şöyle ki:
    %br
    
    :coderay
      #!Ruby
      attr_reader :description
      attr_writer :description
    %br
    
    %p bu kodu sınıf tanımlamanıza şu şekilde eklemelisiniz:
    %br
    
    :coderay
      #!Ruby
      class Thing
        attr_reader :description
        attr_writer :description
        
        # belki buraya da bazı metod tanımları…
      end
    %br
    
    %p
      %b attr_reader 
      metodunu bir oluşum değişkenine (
      %b @description
      ) karşı gelen bir sembol (
      %b :description
      ) ile birlikte çağırmak ‘get erişimcisi’ oluşturur (burada sembol ismi 
      %b description
      ).
    
    %p
      Benzer şekilde 
      %b attr_writer 
      metodu çağırmak , bir oluşum değişkeni için ‘set erişimcisi’ oluşturur. 
      Oluşum değişkenleri nesnenin simgeleri (attribute) kabule edilir, bu yüzden 
      %b attr_reader 
      ve  
      %b attr_writer 
      metodları bu isimleri almıştır.
    %br
    
    %div.alert.alert-info
      %h4 Semboller
      %p
        Ruby’de bir sembol iki nokta üstüste karakteri sonrası gelen bir isimdir (mesela 
        %b :description
        ). 
        %b Symbol 
        sınıfı, Ruby derleyiciye isimleri temsil etmesi amacıyla Ruby sınıflar 
        kütüphanesinde tanımlanmıştır. Bir ya da birkaç sembolü 
        %b attr_reader metoduna gönderdiğinizde (bu metod 
        %b Module 
        sınıfında tanımlıdır) Ruby herbirine karşılık bir oluşum değişkeni üretir ve 
        get erişimci metodlarını tanımlar. Bu erişimci metod değişkenin değerini 
        geri döner erişimci metod ve değişken adlarını sembol adından alırlar. 
        Böylece 
        %b attr_reader(:description) 
        ile 
        %b @description  
        adında bir değişken ve 
        %b decription() 
        adında bir erişimci metod üretilir.
    %br
    
    %h4.sag accessors2.rb
    :coderay
      #!Ruby
      # reading and writing attributes
      class Thing      
        attr_reader :description
        attr_writer :description
        attr_writer :name
        
        def initialize( aName, aDescription )            
          @name = aName
          @description  = aDescription
        end
        
        # get accessor for @name
        def name
          return @name.capitalize
        end
        
        # name için attr_writer tanımladığım için 'set' metod gerekmez   
        #      def name=( aName )
        #                @name = aName
        #      end
        
      end      
      
      class Treasure < Thing      # Treasure Thing sınıfının türevi
        attr_accessor :value
        
        def initialize( aName, aDescription )
          super( aName, aDescription )
        end           
      end
      
      # Programın çalışan kısmı burda başlıyor...
      t1 = Treasure.new("sword", "an Elvish weapon forged of gold")
      t1.value = 800
      t2 = Treasure.new("dragon horde", "a huge pile of jewels")  
      t2.value = 500
      puts "t1 name=\#{t1.name}, description=\#{t1.description}, value=\#{t1.value}"
      t1.value= 100
      t1.description << " (now somewhat tarnished)"     # not << önceki stringin
                                                                         #arkasına yenisini ekler
      puts "t1 name=\#{t1.name}, description=\#{t1.description}, value=\#{t1.value}"
      puts "This is treasure1: \#{t1.inspect}"
      puts "This is treasure2: \#{t2.inspect}"
    %br
    
    %p
      %b accessors2.rb 
      programı attribute reader ve writer metodlarının çalışan birkaç örneğini 
      içeriyor. Thing sınıfı 
      %b @name 
      simgesi için ayrı yoldan ‘get erişimcisi’ tanımlanmış. Neden böyle yapılmış? 
      Çünkü değeri verirken kelimelerin ilk harflerini büyük harfle vermek istemiş 
      ve 
      %b String.capitalize 
      metodu ile değeri olduğu gibi göndermeyip işlemiş ve göndermiş. Böyle 
      durumlar gerekirse önceden gösterdiğimiz gibi ayrı metod yazılır.
    %br
    
    :coderay
      #!Ruby
      def name
        return @name.capitalize
      end
    %br
    
    %p
      %b @name 
      değişkenine bir değer gönderirken bir işlem yapmadan aynen verileceği için 
      özel metod yazmaya gerek görülmemiş 
      %b attr_writer 
      yeterli.
    %br
    
    :coderay
      #!Ruby
      attr_writer :name
    %br
    
    %p
      %b @description 
      değişkeni herhangi bir işleme gerek duymadığından değişkeni okumak ve 
      yazmak için 
      %b attr_reader 
      ve  
      %b attr_writer 
      metodlarını kullandım:
    %br
    
    :coderay
      #!Ruby
      attr_reader :description
      attr_writer :description
    %br
    
    %div.alert.alert-info
      %h4 Attribute ya da Property?
      %p
        Terminoloji sizi yanıltmasın Ruby’de 
        %b ‘attribute’ 
        denen şey diğer dillerdeki 
        %b ‘property’ 
        denilen şeyle aynıdır, bunlar nesnenin özelliklerini belirten simgelerdir.
    %br
    
    %p
      Bir değişkene hem yazma hem okuma isteğiniz varsa ayrı ayrı 
      %b attr_reader 
      ve 
      %b attr_writer 
      metodları kullanmak yerine kısa yoldan 
      %b attr_accessor 
      metodu kullanabilirsiniz. Bunu Treasure sınıfının 
      %b value 
      simgesine erişmek için kullandım:
    %br
    
    :coderay
      #!Ruby
      attr_accessor :value
    %br
    
    %p bu aşağıdaki satırlarla aynı işi yapar:
    %br
    
    :coderay
      #!Ruby
      attr_reader :value
      attr_writer :value
    %br
    
    %p
      Önceleri 
      %b attr_reader 
      metodunun argümanında verilen sembollerle aynı isimde değişken 
      ürettiğinden bahsetmiştim, 
      %b attr_accessor 
      metodu da aynısını yapar
    %p
      Thing sınıfının 
      %b initialize 
      metodu ayrı yoldan değişkenleri tanımlıyor. Treasure sınıfı ise 
      %b @value 
      değişkenine 
      %b initialize 
      metodu içinde bir tanımlama yapmıyor. Sadece 
      %b @value 
      değişkeninin  var olduğunu belirten erişimci tanımlama satırı var:
    %br
    
    :coderay
      #!Ruby
      attr_accessor :value
    %br
    
    %p
      Kaynak dosyasının alt kısmındaki programım her Treasure nesnesi 
      %b value 
      değişkenine nesnenin üretilmesinden sonra ayrı bir operasyonla değer veriyor.
    %br
    
    :coderay
      #!Ruby
      t1.value = 800
    %br
    
    %p
      Bir değer ataması yapmadığımız halde 
      %b @value 
      değişkeni tanımlanmış olduğu için fiziksel olarak mevcuttur ve get 
      erişimcisi ile değeri okunabilir.
    %br
    
    :coderay
      #!Ruby
      t1.value
    %br
    
    %p
      Attribute accessor tarafından 
      %b @value 
      değişkeninin tanımlandığından emin olmak için 
      %b inspect metodu kullanarak içine bakmak gereklidir. Bunu programımın 
      son satırlarında yaptım.
    %br
    
    :coderay
      #!Ruby
      puts "This is treasure1: \#{t1.inspect}"
      puts "This is treasure2: \#{t2.inspect}"
    %br
    
    %h4.sag accessors3.rb
    :coderay
      #!Ruby
      class Thing                      
        attr_reader :name, :description
        attr_writer(:name, :description)
        attr_accessor(:value, :id, :owner)
      end      
      
      t = Thing.new
      t.name = "A Thing"
      t.description = "A soft, furry wotsit"
      t.value = 100
      t.id = "TH100SFW"
      t.owner = "Me"
      puts("\#{t.name} is \#{t.description}, it is worth $\#{t.value}")
      puts("it's id is \#{t.id}. It is owned by \#{t.owner}.")
    %br
    
    %p
      Attribute accessor metodu bir seferde birden fazla simge işleyebilir. Eğer 
      birden fazla simge üretmek istiyorsanız simgeleri temsil eden sembolleri 
      aşağıdaki gibi virgülle ayırırsınız:
    %br
    
    :coderay
      #!Ruby
      attr_reader :name, :description
      attr_writer(:name, :description)
      attr_accessor(:value, :id, :owner)
    %br
    
    %p
      Ruby’de her zaman olduğu gibi parantezler opsiyonel. İster parantezli ister 
      parantezsiz metod çağırılabilir.
    %br
    
    %h4.sag 2adventure.rb
    :coderay
      #!Ruby
      class Thing
        @@num_things = 0     # class değişkeni
        
        attr_reader( :name, :description )
        attr_writer( :description )
        
        def initialize( aName, aDescription )
          @name = aName
          @description = aDescription
          @@num_things +=1        # @@num_things bir artsın
        end
        
        def to_s         # default to_s metodu üzerine yazar
          return "(Thing.to_s):: The \#{@name} Thing is \#{@description}"
        end
        
        def show_classvars
          return "There are \#{@@num_things} Thing objects in this game"
        end
      end
      
      class Room < Thing  
        # TODO: Room’a özel davranışlar buraya konacak...
      end
      
      class Treasure < Thing
        attr_reader :value
        attr_writer :value
        
        def initialize( aName, aDescription, aValue )
          super( aName, aDescription )
          @value = aValue
        end
      end
      
      class Map
        # @rooms değişkeni Room nesnelerinden oluşan
        # bir array olabilir
        def initialize( someRooms )
          @rooms = someRooms
        end
        
        # to_s metodu @rooms içindeki tüm Room nesneleri üzerinde
        # iterasyon yaparak her birinin bilgilerini yazar. Bu metodun
        # ayrıntılarına ilerde tekrar döneceğiz
        def to_s
          @rooms.each {|a_room|
            puts(a_room)          
          }
        end
      end
      
      # önce birkaç nesne üretelim
      #   i) Treasure’lar
      t1 = Treasure.new("Sword", "an Elvish weapon forged of gold",800)
      t2 = Treasure.new("Dragon Horde", "a huge pile of jewels", 550)
      #   ii) Room’lar
      room1 = Room.new("Crystal Grotto", "A glittery cavern")
      room2 = Room.new("Dark Cave", "A gloomy hole in the rocks")
      rom3 = Room.new("Forest Glade", "A verdant clearing filled with shimmering light")
      #   iii) bir Map - az önceki Room’lardan oluşan
      mymap = Map.new([room1,room2,room3])
      # şimdi ne yaptık bir bakalım...
      puts "\nHazinelerimizi bir sıralayalım..."
      puts "Burdaki treasure1: \#{t1.inspect}"
      puts "Burdaki treasure2: \#{t2.inspect}"
      puts "\nşimdi de Thing.to_s metoduna bakalım..."
      puts "Yup, treasure 2 \#{t2.to_s} dir"
      puts "\nşimdi de attribute accessor nasıl çalışıyor bakalım"
      puts “Evet şunları çalıştıralım:"
      puts 't1 name=\#{t1.name}, description=\#{t1.description}, value=\#{t1.value}'
      puts "t1 name=\#{t1.name}, description=\#{t1.description}, value=\#{t1.value}"
      puts "\nŞimdi t1.value değerine 100 girip t1.description’u değiştircez..."
      t1.value = 100
      t1.description << " (now somewhat tarnished)" # not << ile olan stringe yenisi eklenir
      puts "t1 (ŞİMDİ) name=\#{t1.name}, description=\#{t1.description},
        value=\#{t1.value}"
      puts "\nroom1’e bir bakalım..."
      puts "room1 name=\#{room1.name}, description=\#{room1.description}"
      puts "\nve de map..."
      puts "mymap = \#{mymap.to_s}"
      puts "\nSon olarak, kaç tane Thing nesnesi ürettiğimize bakalım..."
      puts( t1.show_classvars )
      # Bir egzersiz olarak, Map sınıfına toplam üretilen Room nesnelerini sayan
      # bir kod ekleyin
    %br
    
    %p
      Şimdi adventure oyununda attribute reader ve writer metodlarının nasıl 
      kullanıldığını inceleyelim. yukardaki 
      %b 2adventure.rb 
      programına bakalım. Thing sınıfında iki tane okunabilir simge var 
      %b name 
      ve 
      %b description. 
      Ama sadece description için yazma simgesi oluşturdum, çünkü 
      %b name 
      simgesini üretildikten sonra değiştirmek istemiyorum, bu yüzden 
      %b name 
      üzerine yazılamaz:
    %br
    
    :coderay
      #!Ruby
      attr_reader( :name, :description )
      attr_writer( :description )
    %br
    
    %p
      Treasure sınıfının açıklamasını yapmak için default 
      %b to_s 
      metodu üzerine yeni metod yazdım. Tekrar hatırlatalım tüm Ruby 
      sınıflarında bu 
      %b to_s metodu standarttır. 
      %b Thing.to_s 
      metodu eski metodun üzerine yazar. Ruby’de eski metodların üzerine 
      yazarak metod davranışlarını istediğiniz gibi değiştirebilirsiniz.
    %br
    
    %h3 ÜST SINIFIN METODLARINI ÇAĞIRMAK
    %p
      Oyunumuzda Thing sınıfının torunu iki sınıfımız var. Treasure sınıfı 
      yazılıp okunabilen bir 
      %b value 
      simgesini ekliyor. Dikkat ederseniz onun 
      %b initialize metodu 
      %b @value değişkenine değer vermeden önce 
      %b name 
      ve 
      %b description 
      simgelerine değer vermek için üst sınıfını çağırıyor:
    %br
    
    :coderay
      #!Ruby
      super( aName, aDescription )
      @value = aValue
    %br
    
    %p
      Eğer burada üst sınıfı çağırmayı unutsaydım 
      %b name 
      ve 
      %b description 
      simgeleri asla tanımlanamayacaktı. Çünkü 
      %b Treasure.initialize 
      metodu 
      %b Thing.initialize 
      metodu üzerine yazacak ve 
      %b Thing.initialize 
      metodu Treasure nesnesi üretilirken çağırılmayacaktı.
    %p
      Diğer yandan, Thing’den torun bir diğer sınıf Room 
      %b initialize 
      metoduna sahip değil. Yani yeni bir Room nesnesi üretildiğinde Ruby onda 
      olmadığı için atası olan sınıflarda bulduğu ilk 
      %b initialize  
      metodunu otomatik olarak çağırır (yani Thing sınıfının metodunu); böylece 
      Room nesnesinin 
      %b name 
      ve 
      %b description 
      simgeleri orada üretilir.
    %br
    
    %h3 SINIF DEĞİŞKENLERİ (CLASS VARIABLES)
    %p
      Bu programda enteresan birkaç şey daha var. Tam Thing sınıfının 
      tepesinde şunu göreceksiniz:
    %br
    
    :coderay
      #!Ruby
      @@num_things = 0
    %br
    
    %p
      İki 
      %b @ 
      karakteri ile başlayan 
      %b @@num_things 
      değişkeni bir ‘sınıf değişkeni’ dir. Şimdiye kadar sınıflarda kullandığımız 
      değişkenler oluşum değişkenleriydi. 
      %b @name 
      ‘de olduğu gibi tek bir 
      %b @ 
      ile başlıyordu. Her yeni üretilen nesnenin (oluşumun) kendi oluşum 
      değişkenleri vardır. Fakat bir sınıftan üretilen tüm nesneler aynı sınıf 
      değişkenini kullanır. 
      %b @@num_things 
      değişkenine 0 değeri vererek bir sayı olduğunu belirtmiş oldum.
    %p
      Burada 
      %b @@num_things 
      sınıf değişkeni oyundaki tüm nesnelerin sayısını akılda tutmak için tanımlandı. 
      Bunu sağlamak için 
      %b initialize 
      metodu her çağrıldığında sayıyı arttırıyor (sayıya 1 eklemek için: 
      %b += 1 
      kullanılır ):
    %br
    
    :coderay
      #!Ruby
      @@num_things +=1
    %br
    
    %p
      Eğer kodumda aşağı doğru ilerlerseniz, Room nesnelerinden oluşan bir 
      array içeren Map sınıfı tanımı vardır. Bunun içindeki her Room 
      nesnesinin ayrıntılarını gösteren bir 
      %b to_s 
      metodu var. Map sınıfının kodu hakkında bir endişeye kapılmayın, 
      array yapılarını ilerde göreceğiz.
    %p
      Programın alt sıralarında çalıştırılan kodu inceleyin ve çalıştırarak 
      %b @@num_things 
      sınıf değişkeninin nasıl kullanıldığını inceleyin.
    .alert.alert-info
      %h4 Sınıf ve Oluşum Değişkenleri
      %br
      %img.displayed(src="/class_var.png" alt="/class_var.png")
      %br
      %p
        Bu şekilde Thing sınıfı (dikdörtgen olan) 
        %b @@num_things 
        adında bir sınıf değişkeni ve 
        %b @name 
        adında bir oluşum değişkenine sahip. Üç oval şekil Thing nesnelerini 
        gösterir - bunlar Thing sınıfının oluşumları. Bu nesnelerin herhangi biri 
        %b @name 
        oluşum değişkenine değer verirse herbiri farklı değerler alacaktır - 
        her nesnenin bağımsız 
        %b @name 
        değişkeni vardır. Fakat sınıf değişkeni olan 
        %b @@num_things 
        Thing sınıfının içinde yaşar ve sınıfın tüm oluşumları aynı değeri okur 
        ve aynı değere yazar. Burada 
        %b @@num_things 
        değeri 3 tür ve tüm oluşumlar bu değeri 3 olarak görür.
    %br
    %hr
      
    %h1 Derin İnceleme
    %h3 SÜPERCLASS'lar
    %h4.sag super.rb
    :coderay
      #!Ruby
      # The Book of Ruby - http://www.sapphiresteel.com

      class Thing       # aşağıdaki tüm sınıfların dedesi
        def initialize( aName, aDescription )
          @name = aName
          @description = aDescription
          puts("Thing.initialize: \#{self.inspect}\n\n")
        end
        
        def aMethod( aNewName )
          @name = aNewName
          puts("Thing.aMethod: \#{self.inspect}\n\n")
        end
      end

      class Thing2 < Thing
        def initialize( aName, aDescription )		
          super	    # super kelimesinin kendisine gelen tüm parametreleri 
                      # üst sınıfına gönderen şekli
          # super( aName, aDescription ) ## <- üst satırın eşleniği olur
          @fulldescription = "This is \#{@name}, which is \#{@description}"
          puts("Thing2.initialize: \#{self.inspect}\n\n")
        end
        
        def aMethod( aNewName, aNewDescription )
          # dikkat ederseniz aNewDescription argümanı fala çünkü kullanılmıyor
          super( aNewName )		
          puts("Thing2.aMethod: \#{self.inspect}\n\n")
        end
      end

      class Thing3 < Thing2
        def initialize( aName, aDescription, aValue )
          super( aName, aDescription )
          @value = aValue
          puts("Thing3.initialize: \#{self.inspect}\n\n")
        end
        
        def aMethod( aNewName, aNewDescription, aNewValue )
          super( aNewName, aNewDescription )
          @value = aNewValue		
          puts("Thing3.aMethod: \#{self.inspect}\n\n")
        end
      end	

      class Thing4 < Thing3
        def aMethod
          puts("Thing4.aMethod: \#{self.inspect}\n\n")
        end
      end

      class Thing5 < Thing4
      end


      ### Birkaç metod kodu test etmek için kullanalım
      ### --- Thing object ---

      def test1
        puts( "------------- TEST 1 ------------------" )
        t = Thing.new( "A Thing", "a lovely thing full of thinginess" )
        t.aMethod( "A New Thing" )
      end

      ### --- Thing2 object ---

      def test2
        puts( "------------- TEST 2 ------------------" )
        t2 = Thing2.new( "A Thing2", "a Thing2 thing of great beauty" )
        t2.aMethod( "A New Thing2", "a new Thing2 description" )
      end

      ### --- Thing3 object ---

      def test3
        puts( "------------- TEST 3 ------------------" )
        t3 = Thing3.new( "A Thing 3", "a Thing3 full of Thing and Thing2iness", 500 )
        t3.aMethod( "A New Thing3", "and a new Thing3 description", 1000 )
      end

      ### --- Thing4 object ---

      def test4
        puts( "------------- TEST 4 ------------------" )
        t4 = Thing4.new( "A Thing4", "the nicest Thing4 you will ever see", 10 )
        t4.aMethod
      end

      ### --- Thing5 object ---

      def test5
        puts( "------------- TEST 5 ------------------" )
        t5 = Thing5.new( "A Thing5", "a very simple Thing5", 40 )
        t5.aMethod
      end

      # 'ana' çevrim
      ans = ''
      puts( "Run Test 1, 2, 3, 4, 5?\nWrite a number or 'q' to quit. Then press [Enter] key\n\n" )
      until ans == 'q' do  
        puts( "[ Enter 1, 2, 3, 4, 5 or 'q'? ]" )
        print( "> " )
        ans = gets[0].chr().downcase()
        case ans 
        when '1' then test1()
        when '2' then test2()
        when '3' then test3()
        when '4' then test4()
        when '5' then test5()
        end	  
      end 
    %br

    %p
      super kelimesinin nasıl çalıştığını anlamak için örnek program 
      %b super.rb 
      programına bakın. Burada beş birbirine bağlı sınıf var: Thing sınıfı diğer 
      hepsinin dedesi. Thing'den Thing2 olmuş, Thing2'den Thing3 olmuş, 
      sonra Thing4 sonra Thing5.
    %p
      İlk üç sınıfı biraz inceleyelim. Thing sınıfında iki oluşum değişkeni var 
      %b @name 
      ve
      %b @description 
      Thing2 ayrıca 
      %b @fulldescription 
      (@name ve @description'dan üretme bir string) değişkenini tanımlamış. 
      Thing3 bir başka değişken daha tanımlıyor, 
      %b @value.
    %p
      Bu üç sınıf yeni bir nesne üretildiğinde değişkenlere değer veren 
      %b initialize 
      metoduna sahip. Ayrıca her birinin bir yada birkaç değişkeni değiştiren 
      yaratıcı bir isme sahip 
      %b aMethod 
      metodu var. Türemiş sınıflar Thing2 ve Thing3 her ikisi de metodlarında 
      %b super 
      kelimesini kullanmaktalar.
    %br
    
    .alert.alert-info
      %p
        %b super.rb 
        programını terminalde çalıştırın ve değişik kısımlarını test etmek için 
        sorlduğunda 1 den 5 e bir rakam girin ya da q girerek programdan çıkın.
    %br
    
    %p
      Programın alt kısımlarında bir 'ana çevrim' var bu çevrim program çalıştıkça 
      dönüp duruyor. Buranın kodunu merak etmeyin ilerki bölümlerde 
      ayrıntılı üzerinde duracağız. Bunu programın değişik kısımlarını tekrar 
      tekrar deneyin diye yaptım. 
      %b test1 
      den 
      %b test5 
      e kadar metodların etkilerini inceleyin diye. İlk defa çalıştırdığınızda 
      %b 1 
      girerek 
      %b test1 
      metodunu çalıştırın. Bu metod iki satır koda sahip:
    %br
    
    :coderay
      #!Ruby
      t = Thing.new( "A Thing", "a lovely thing full of thinginess" )
      t.aMethod( "A New Thing" )
    %br
    
    %p
      Buradaki ilk satır bir Thing nesnesi üretir ve ikinci satır da 
      %b aMethod 
      metodunu çağırır. Thing sınıfı hiçbir yerden türememiş olduğundan (
      Aslında tüm Ruby sınıfları Object sınıfından türemiştir, ama burda 
      anlatılmak istenen programcı tarafından üretilen bir sınıftan türemediği) 
      burada ilgi çekecek bir hareket yok. Çıktı 
      %b Thing.initialize 
      ve 
      %b Thing.aMethod 
      metodları çağrılmasından sonraki etkiyi göstermek için 
      %b inspect 
      metodunu kullanır. 
      %b inspect 
      metodu, tüm nesneler için bir debug aracı olarak kullanılabilir. Burada bize 
      üretilen nesnenin özel tanımlama numarası olan bir hexadesimal sayı ve 
      arkasından 
      %b @name 
      ve 
      %b @description 
      değişkenlerinin değerlerini gösterir
      
    %p
      Şimdi çıktı terminalinde 
      %b 2 
      girerek 
      %b test2 
      metodunu çalıştırın. Bu metod Thing2 nesnesi 
      %b t2'
      yi üretir ve 
      %b t2.aMethod 
      metodunu çağırır:
    %br
    
    :coderay
      #!Ruby
      t2 = Thing2.new( "A Thing2", "a Thing2 thing of great beauty" )
      t2.aMethod( "A New Thing2", "a new Thing2 description" )
    %br
    
    %p
      Çıktıya dikkatle bakın. 
      %b t2 
      her nekadar Thing2 nesnesi de olsa , ilk önce Thing sınıfının 
      %b initialize 
      metodu çağrılır. Nasıl olduğunu anlamak için Thing2 sınıfının 
      %b initialize 
      metoduna bir bakın:
    %br
    
    :coderay
      #!Ruby
      def initialize( aName, aDescription )
        super
        @fulldescription = "This is \#{@name}, which is \#{@description}"       
        puts("Thing2.initialize: \#{self.inspect}\n\n")
      end 
    %br
    
    %p
      Burada 
      %b super 
      kelimesi Thing2'nin atası yada 'superclass'ının 
      %b initialize 
      metodunu çağırıyor. Thing2'nin superclass'ı tanımlamasından da görüleceği 
      üzere Thing sınıfı:
    %br
    
    :coderay
      #!Ruby 
      class Thing2 < Thing
    %br
    
    %p
      Ruby'de 
      %b super 
      kelimesi tek başına kullanıldığında (argüman verilmeden) bulunduğu sınıfın 
      bulunduğu metoda (burada
      %b Thing2.initialize
      ) gönderilen tüm argümanları üst sınıflardaki ilk bulduğu aynı isimdeki 
      metoda (burada 
      %b Thing.initialize
      ) gönderir. Alternatif olarak 
      %b super 
      kelimesine bir kısım argüman ekleyebilirsiniz. Buradaki durumda aşağıdaki 
      kod aynı işlemi yapacaktır:
    %br
    
    :coderay
      #!Ruby
      super( aName, aDescription )
    %br
    
    %p
      Her nekadar 
      %b super 
      kelimesinin argümansız kullanımına müsaade edilse de anlam berraklığı 
      bakımından size superclass'a gönderilen argümanları yazmanızı öneririm. 
      Mesela Thing2'nin 
      %b aMethod'
      u Thing sınıfına sadece 
      %b aName 
      argümanı göndermekte:
    %br
    
    :coderay
      #!Ruby
      super( aNewName ) 
    %br
    
    %p
      Bu yüzden 
      %b Thing2.aMethod 
      çağrıldığında 
      %b @description 
      değeri değişmez.
    %p
      Şimdi eğer Thing3'e bakarsanız, bunun da bir yeni değişken eklediğini 
      göreceksiniz 
      %b @value. Onun 
      %b initialize 
      metodu yapılandırmasında 
      %b aName 
      ve 
      %b aDescription 
      superclass'ı olan Thing2'ye gönderiliyor. Bildiğiniz gibi Thing2 de bunları 
      süperclass'ı olan Thing'e göndermekte.
    %p 
      Programın çalıştırılmasıyla beraber consolda seçenek olarak 
      %b 3 
      girin, bu durumda şu kod çalışacaktır:
    %br
    
    :coderay
      #!Ruby
      t3 = Thing3.new("A Thing 3", "a Thing3 full of Thing and Thing2iness",500)
      t3.aMethod( "A New Thing3", "and a new Thing3 description",1000) 
    %br
    
    %p
      Hiyerarşide 
      %b initialize 
      ve  
      %b aMethod 
      metodlarının nasıl çağrılıp işlendiğine dikkat edin. 
    %p
      Örnekte yaptığım gibi bir superclass metodu üzerine yazmak gerekli 
      bişey değil. Bu sadece yeni bir davranış kazandırmak istediğinizde 
      geçerlidir. Thing4 
      %b initialize metodunu atlar ve 
      %b aMethod 
      metodu üzerine yazar.
    %p
      Consolda girdi olarak 
      %b 4 
      girerek şu kodu çalıştırırsınız:
    %br
    
    :coderay
      #!Ruby
      t4 = Thing4.new( "A Thing4", "the nicest Thing4 you will ever see", 10 )
      t4.aMethod
    %br
    
    %p
      Bunu çalıştırdığınızda 
      %b initialize 
      metodu çağrılırken Thing4'te tanımlanmadığı için superclass metodu 
      %b Thing3.initialize 
      metodu çağrıldığını görürsünüz. Fakat 
      %b aMethod 
      metodu eskisini çağırmadığı için onun yerine geçer ve sadece Thing4 
      sınıfında tanımlanan metod içindekiler çalışır. 
    %p
      Son olarak Thing5 sınıfı Thing4 sınıfından türetilir ve hiç bişey değiştirmez. 
      Consolda seçenek olarak 
      %b 5 
      girin ve şu kod çalışır:
    %br
    
    :coderay
      #!Ruby
      t5 = Thing5.new( "A Thing5", "a very simple Thing5", 40 )
      t5.aMethod
    %br
    
    %p
      Bu sefer de Ruby ilk 
      %b initialize 
      metodunu bulana kadar üst sınıflara gider. Burda önce Thing5'e bakılır 
      olmayınca Thing4'e orda da olmadığı için Thing3 metodu çağırılacaktır. 
      (Bu da Thing2 ve Thing metodlarına çağrı yapar) Ama 
      %b aMethod 
      metodunun ilk uygulaması Thing4'te olduğu için onunki çağırılır.
    %br
    %h4.sag superclasses.rb
    :coderay
      #!Ruby
      
      class One
      end
      
      class Two < One
      end
      
      class Three < Two
      end
      
      # Three sınıfından bir nesne üretelim 
      # ve sınıf adını yazalım
      ob = Three.new
      x = ob.class
      puts( x )
      
      # şimdi hiyerarşide yukarı doğru giderek 
      # nesnemizin atalarına bakalım
      begin
        x = x.superclass
        puts(x) 
      end until x == nil 
    %br
    
    .alert.alert-info
      %p Nihayetinde tüm Ruby sınıfları Object sınıfından türemiştir.
      %p
        Object sınıfının kendisi superclass sahibi olmadığından superclass'ına 
        yapılacak işlemler 
        %i nill 
        değeri dönecektir.
      %br
      
      :coderay
        #!Ruby
        begin
          x = x.superclass
          puts(x) 
        end until x == nil
      %br
    %br
    
    %h3 SINIFLARIN İÇİNDEKİ SABİTLER
    %br
    %p
      Bazen sınıf içinde tanımlanmış sabitlere (bir değeri olan  ve isimleri 
      büyük harfle başlayan tanımlar) erişmemiz gerekir. Diyelim şöyle bir sınıf 
      tanımınız var:
    %br
    
    %h4.sag classconst.rb
    :coderay
      #!Ruby
      
      class X
        A = 10
        
        class Y
          def xyz
            puts( "goodbye" )
          end
        end
        
        def self.abc
          puts("hello")
        end
      end
      
      puts( X::A )
      X::abc		# sınıf metodlarına da :: ile erişebilirsiniz
      X.abc		# tabi tek bir nokta da burda çalışır
      
      ob = X::Y.new   # sınıf içinde sınıf
      ob.xyz
    %br
    
    %p
      Burada sabit olan 
      %b A'
      ya erişmek için özel bir kapsam inceleme operatörü olan 
      %b :: 
      operatörünü kullanmalısınız:
    %br
    :coderay
      #!Ruby
       X::A
    %br
    
    %p
      Sınıf isimleri de sabitlerdir. Bu yüzden aynı operatör ile sınıf içindeki 
      tanımlanmış sınıflara da erişebilirsiniz. Bu sayede içiçe sınıflarda nesne 
      tanımlaması yapılabilir mesela 
      %b X 
      içindeki 
      %b Y 
      gibi:
    %br
    
    :coderay
      #!Ruby
      ob = X::Y.new
    %br
    
    %h3 Kısmi Sınıflar (Partial Classes)
    %p
      Ruby'de bir sınıfın tamamını bir tek yerde tanımlamak gerekmez. Eğer isterseniz 
      programınızın değişik yerlerinde sınıf tanımlamanızı parça parça yapabilirsiniz. 
      Bir sınıf bir diğer sınıftan türemişse sonradan gelen kısmı sınıf 
      tanımlamasında da 
      %b < 
      operatörü kullanılması opsiyondur. Burada iki sınıf tanımladım 
      %b A 
      ve ondan türeme 
      %b B 
      sınıfları:
    %br
    
    %h4.sag partial_classes
    :coderay
      #!Ruby
      class A
        def a
          puts( "a" )
        end
      end

      class B < A
        def ba1
          puts( "ba1" )
        end
      end

      class A
        def b
          puts( "b" )
        end
      end

      class B < A
        def ba2
          puts( "ba2" )
        end
      end
      
      
      class Array
        def gribbit
          puts( "gribbit" )
        end
      end
    %br
    
    %p Şimdi eğer bir B nesnesi üretirsem, A ve B'nin tüm metodlarını kullanabilirim:
    %br
    
    :coderay
      #!Ruby

      ob = B.new
      ob.a
      ob.b
      ob.ba1
      ob.ba2
      [1,2,3].gribbit
    %br
    
    %p
      Ayrıca isterseniz Ruby'nin standart kütüphanesindeki sınıflara da kısmi 
      sınıf eklemeleri yapabilirsiniz. Mesela Array'lere:
    %br
    
    :coderay
      #!Ruby
      class Array
        def gribbit
          puts( "gribbit" )
        end
      end
    %br
    
    %p
      Bu Ruby Array sınıfına 
      %b gridbit 
      metodunu ekler. Bu noktadan sonra array kullanırken bu metodu da çağırabilirsiniz:
    :coderay
      #!Ruby
      [1,2,3].gribbit
    %br
    %p.orta Copyright © 2009 Huw Collingbourne
    
    %hr
    %a.btn.btn-large.btn-success.pull-left(href="/kitap/1")
      %i.icon-backward.icon-white
      Bölüm 1 Stringler, Sayılar, Sınıflar ve Nesneler
    %a.btn.btn-large.btn-success.pull-right(href="/kitap/3")
      Bölüm 3 Stringler ve Range
      %i.icon-forward.icon-white
      


%hr

#disqus_thread
%script(type="text/javascript" async="true" src="http://ruby-tr.disqus.com/embed.js")
  
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
